@require: base/base
@require: base/option-ext

@import: sexp

module CrossRefExt-Type : sig

type 'a t

val make : (|
  to-sexp : 'a -> CrossRefExt-SExp.t;
  from-sexp : CrossRefExt-SExp.t -> 'a option;
  name : string;
|) -> 'a t
val to-sexp : ('a t) implicit -> 'a -> CrossRefExt-SExp.t
val from-sexp : ('a t) implicit -> CrossRefExt-SExp.t -> 'a option
val name : 'a t -> string
val to-string : ('a t) implicit -> 'a -> string
val read-from-string : ('a t) implicit -> string -> 'a option

val int : int t
val string : string t

end = struct

type sexp = CrossRefExt-SExp.t

type 'a t = (|
  to-sexp : 'a -> sexp;
  from-sexp : sexp -> 'a option;
  name : string;
|)

let make rec = rec
let to-sexp tp = tp#to-sexp
let from-sexp tp = tp#from-sexp
let name tp = tp#name

let to-string tp x = CrossRefExt-SExp.to-string (to-sexp tp x)

let read-from-string tp str =
CrossRefExt-SExp.read-from-string str
|> Option.and-then (from-sexp tp)

let from-sexp-def =
let f _ = Option.none in
(|
  symbol = f;
  string = f;
  int = f;
  list = f;
|)

let int = make (|
  name = `int`;
  to-sexp = CrossRefExt-SExp.of-int;
  from-sexp = CrossRefExt-SExp.fold (|
    from-sexp-def with
    int = Option.some;
  |);
|)

let string = make (|
  name = `string`;
  to-sexp = CrossRefExt-SExp.of-string;
  from-sexp = CrossRefExt-SExp.fold (|
    from-sexp-def with
    string = Option.some;
  |);
|)

end
